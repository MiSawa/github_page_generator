---

title: Hollow Heap
date: 2015/04/24
tags: [heap, データ構造]
secret: false

---
<div style="display:none">$$
\newcommand{\seq}[1]{\left(\,#1\,\right)}
\newcommand{\pos}[2]{\stackrel{#1}{\stackrel{\smile}{#2}}}
$$</div>

# Hollow Heaps

## Abstract

Fibonacci heap と同等の操作を実現する, シンプルなデータ構造である Hollow heap を紹介する.

利点は,

0. decrease-key は最悪計算量 `$O(1)$` で, cut も発生しない.

0. 全ての compare の結果がデータ構造に explicit に利用され, 無駄がない.

0. 各ノードは `$3$` つのポインタしか持たず, par も要らない. children は singly linked.

Hollow heaps は二つのアイディアを使っている.

0. decrease-key は lazy deletion と re-insertion で実現する.
   これにより, "hollow"(中身の無い) ノードが作られる.

0. heap を 木 や 森 ではなく DAG で表現する.

Thm3.5 を見ると, amortized で delete は `$O(\log N)$`, それ以外 `$O(1)$`.


## Introduction

次の操作をサポートしたい.

- make-heap()
  - empty heap を返す.

- find-min(h)
  - heap h に入っている最小の key を持つ elem を返す.

- insert(elem, key, h)
  - heap h に elem を key で挿入.

- delete-min(h)
  - heap h から find-min(h) を削除.

- meld(h1, h2)
  - disjoint な elem を持つ h1 と h2 をくっつける.

- decrease-key(e, k, h)
  - h の elem e に付随する key が k 以上な時に適用できる.
    key を k に変える.

- delete(e, h)
  - h から elem e を消す.

make-heap, find-min 以外は破壊的.


- section 2: hollow heap を説明する.
- section 3: analyze.
- section 4: 別バージョン (DAG じゃなくて木?)
- section 5: rebuilding process (hollow heap の時間/空間計算量を削減).
- section 6: section 2 のやつの実装.
- section 7: section 4 のやつの実装.
- section 8: efficient だったりそうじゃなかったりする variants.
- section 9: final remarks.


## Hollow Heaps

我々のデータ構造は, well-known な一般的なヒープの表現を引き継ぎ, 拡張している.
この構造は, "内在的" というよりは "外在的" である.

nodes は items であるというより items を "保持" していると見るべきで,
node 間で item を動かすのは, 内在的じゃなくて外在的.


Fibonacci heap を含む多くのヒープは set of ordered trees だった.
ordered tree は, 各ノードが items を保持していて, key は par の key より小さくないという制約がある感じの.

我々はこのアイディアを拡張し, tree じゃなくて DAG にして, 各ノードは item を保持してたりしてなかったりするようにした.

木から拡張したので, 木っぽい用語を使う.
`$(u, v)$` : DAG の辺に対し, `$v$` は `$u$` の親, `$u$` は `$v$` の子であると呼ぶ.
(内向き木なんだね.)

それから, par を持たないノードを root と呼ぶ.


non-empty なヒープは, DAGの各ノードがたかだか一つのアイテムを保持しているものとする.

ノードが "full" であるとは, item を保持していることで, "hollow" であるとは, 保持していないこと.

ノードが作られる時は "full" で, delete されたり move されたりして "hollow" になったりする.

一度 hollow になったらそのまま destroy されるまで hollow のまま.

もし u が full なら, u.item と u.key でそれらを表す.
u が hollow な時は, null と, hollow になる直前の key を表す.


full node は高々一つの親を持ち, hollow node は高々二つの親を持てる.

DAG は key で topologically ordered とする.
これを "heap order" と呼ぶ.

delete operation の最中以外, この DAG は一つの full root を持ち, hollow root は持たない.

heap order から, 当然この full root が minimum key になる.



さて, heap operations で重要な役割を果たす link というのを説明しよう.
二つの full root `$v, w$` が与えられた時, `link($v$, $w$)` は, key のでかい方を小さい方の子にする操作である.
もし同じなら, `$v$` を `$w$` の子にする.

子の方を "loser", 親を "winner" と呼ぶ.
Link は full root を一つ減らし, そいつに "first parent" を与える操作である.

この時点で, いくつかの操作は自明に出来る.

- make-heap
  - empty DAG を返す.
- find-min
  - root.item を返す.
- meld(h1, h2)
  - どちらも empty でないなら, h1 の root と h2 の root を link する.
- insert
  - full node 一つからなる DAG を作って meld.
- decrease-key(e, k, h)
  - lazy にやる.
  - もし u == h, i.e. u が root なら, 単に u.key = k する.

  - そうでないなら u を hollow にして, 新しく v を作って, link(h, v) をする.
    もし v が loser なら, u を v の child にする.
  - もし decrease-key が v を u の親にしたなら, u の親が二つになる. この v を second parent of u と呼ぼう.
  - hollow になるのは高々一回だから, second parent は高々一つ. (これ以外で second parent は作らないっぽい?)
- delete-min
  - delete (find-min)
- delete
  - u を hollow にする. (この場合は second parent が作られない hollow のなりかた)
  - もし u が root でなければ, delete は終わり.
  - そうでなければ, こいつを削除し, children をまとめて一つの DAG にする.
  - 具体的には, 新しく出来た hollow root は delete し, そうでないのは link して潰す.


我々が選択出来るのは, delete でする link の戦略だけ.
ここで, 各ノードに rank という非負整数を与えておくことにしよう.
これで, ranked link という link の特殊なやつを定義する:

- ranked link は同じ rank のものしか link できず, winner を ++ する.

rank を変えないのは unranked link と呼ぶ.

child が ranked/unranked であるとは, 最も first parent を得たのが unranked だったか ranked だったかを指す.

ranked link は, efficiency を保証したい所だけで使うから, meld とか decrease-key では使わない.

delete では, hollow roots を消し去った後, ranked link を出来る限り行なって, rank が全て異なるようになったら unranked link をやる.

あとは, initial node rank を定めるだけ.

- insert で作られたのは 0,
- decrease-key で `$u$` から作られた `$v$` のは `$\max\{0, u.{\rm rank} - 2\}$`,

にする.







